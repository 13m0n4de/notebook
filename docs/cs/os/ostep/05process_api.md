# 第 5 章 插叙：进程 API

这章只是介绍了一些有关进程的 API 。

| 系统调用 | 功能        | 返回值                                     | 备注                                                                                                                    |
| :--- | :-------- | :-------------------------------------- | :-------------------------------------------------------------------------------------------------------------------- |
| fork | 创建子进程     | 在父进程中返回子进程的 PID ，子进程中返回 `0` ，失败时返回 `-1` | 子进程会复制一份父进程的内存内容，但它们在不同的内存空间，运行 `mmap` 等不会互相影响                                                                        |
| wait | 等待子进程运行完毕 | 成功时返回结束的子进程 PID ，失败时返回 `-1`             | 调用 `wait()` 等于调用 `waitpid(-1, &wstatus, 0)` ，会等待任意一个子进程结束                                                             |
| exec | 执行新的程序    | 只有发生错误才会返回，返回 `-1`                      | 它实际做的是使用新的进程映像替换当前进程映像，从可执行程序中加载代码和静态数据，并用它覆写自己的代码段（以及静态数据），堆、栈及其他内存空间也会被重新初始化。所以 `exec()` 等函数执行成功后没法返回，因为原有的程序已经被替换了 |

## 作业

!!! question
    1．编写一个调用 fork()的程序。在调用 fork()之前，让主进程访问一个变量（例如 x）并将其值设置为某个值（例如 100）。子进程中的变量有什么值？当子进程和父进程都改变 x的值，变量会发生什么？

!!! question
    2．编写一个打开文件的程序（使用 open()系统调用），然后调用 fork()创建一个新进程。子进程和父进程都可以访问 open()返回的文件描述符吗？当它们并发（即同时）写入文件时，会发生什么？

!!! question
    3．使用 fork()编写另一个程序。子进程应打印“hello”，父进程应打印“goodbye”。你应该尝试确保子进程始终先打印。你能否不在父进程调用 wait()而做到这一点呢？

!!! question
    4．编写一个调用 fork()的程序，然后调用某种形式的 exec()来运行程序/bin/ls。看看是否可以尝试 exec()的所有变体，包括 execl()、execle()、execlp()、execv()、execvp()和 execvP()。为什么同样的基本调用会有这么多变种？

!!! question
    5．现在编写一个程序，在父进程中使用 wait()，等待子进程完成。wait()返回什么？如果你在子进程中使用 wait()会发生什么？

!!! question
    6．对前一个程序稍作修改，这次使用 waitpid()而我是 wait()。什么时候 waitpid()会有用？

!!! question
    7．编写一个创建子进程的程序，然后在子进程中关闭标准输出（STDOUT_FILENO）。如果子进程在关闭描述符后调用 printf()打印输出，会发生什么？

!!! question
    8．编写一个程序，创建两个子进程，并使用 pipe()系统调用，将一个子进程的标准输出连接到另一个子进程的标准输入。
